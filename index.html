<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>RTS World Takeover with Enemies & Nukes</title>
<style>
  :root {
    --bg:#071225; --panel:#0f1724; --accent:#ffd166; --muted:#9aa8bd;
    --player:#06d6a0; --enemy1:#ff6b6b; --enemy2:#f4a261; --neutral:#9aa8bd;
  }
  html, body {
    margin:0; padding:0; height:100%; background:#071225; color:#e6eef6;
    font-family: Arial, sans-serif;
    user-select: none;
  }
  #container {
    display:flex; max-width: 1100px; margin: 20px auto; gap: 12px;
  }
  #game {
    background:#0b2236; border-radius:8px; flex: 1 1 auto;
    width: 864px; height: 576px; display: block;
  }
  #sidebar {
    width: 320px; background: var(--panel); border-radius: 8px; padding: 12px;
    box-sizing: border-box;
  }
  h1 {
    margin: 0 0 12px 0;
    font-weight: 600;
    font-size: 22px;
    color: var(--accent);
  }
  button {
    background: var(--player);
    border: none;
    border-radius: 6px;
    padding: 10px 14px;
    font-weight: bold;
    cursor: pointer;
    color: #022;
    margin: 6px 6px 6px 0;
    user-select:none;
  }
  button.danger {
    background: #d72631;
    color: white;
  }
  button.toggle {
    background: transparent;
    color: var(--muted);
    border: 1px solid var(--muted);
  }
  #stats p {
    margin: 6px 0;
    font-size: 14px;
    color: var(--muted);
  }
  #instructions {
    font-size: 13px;
    color: var(--muted);
    margin-top: 14px;
  }
  #footer {
    text-align: center;
    margin-top: 14px;
    font-size: 12px;
    color: var(--muted);
  }
</style>
</head>
<body>

<div id="container">
  <canvas id="game" width="864" height="576"></canvas>
  <div id="sidebar">
    <h1>RTS World Takeover</h1>
    <div id="stats">
      <p><strong>Your Resources:</strong> <span id="resources">0</span></p>
      <p><strong>Your Territories:</strong> <span id="owned">0</span> / <span id="total">0</span></p>
      <p><strong>Game Time:</strong> <span id="time">0</span>s</p>
    </div>
    <div id="controls">
      <button id="buildUnitBtn">Build Unit (10)</button>
      <button id="launchNukeBtn" class="danger">Launch Nuke (50)</button>
      <button id="toggleSpeedBtn" class="toggle">Toggle Fast AI</button>
      <button id="restartBtn" class="toggle">Restart Game</button>
    </div>
    <div id="instructions">
      <p>Controls:</p>
      <ul>
        <li>Click your territory to select it.</li>
        <li>Then click another territory to send units.</li>
        <li>Hold <em>Shift</em> to send half your units.</li>
        <li>Build units and launch nukes using resources.</li>
        <li>Pause/resume with Spacebar.</li>
      </ul>
    </div>
    <div id="footer">Made for you â€” enjoy conquering the world!</div>
  </div>
</div>

<script>
(() => {
  const config = {
    cols: 12,
    rows: 8,
    tileSize: 72,
    productionInterval: 3,
    unitCost: 10,
    nukeCost: 50,
    unitSpeed: 80,
    aiTickInterval: 2.5,
    startResources: 50,
    nukeRadius: 1.5,
  };

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;

  const resourcesEl = document.getElementById('resources');
  const ownedEl = document.getElementById('owned');
  const totalEl = document.getElementById('total');
  const timeEl = document.getElementById('time');

  const buildUnitBtn = document.getElementById('buildUnitBtn');
  const launchNukeBtn = document.getElementById('launchNukeBtn');
  const toggleSpeedBtn = document.getElementById('toggleSpeedBtn');
  const restartBtn = document.getElementById('restartBtn');

  const FACTIONS = {
    neutral: 0,
    player: 1,
    enemy1: 2,
    enemy2: 3,
  };

  const COLORS = {
    0: '#9aa8bd',   // neutral
    1: '#06d6a0',   // player
    2: '#ff6b6b',   // enemy1
    3: '#f4a261',   // enemy2
  };

  let state = {
    time: 0,
    resources: config.startResources,
    tiles: [],
    units: [],
    selected: null,
    paused: false,
    lastProduction: 0,
    lastAITick: 0,
    aiFast: false,
  };

  function tileIndex(c, r) {
    return r * config.cols + c;
  }

  function tileCoords(i) {
    return {c: i % config.cols, r: Math.floor(i / config.cols)};
  }

  function centerOfTile(c, r) {
    return {
      x: c * config.tileSize + config.tileSize / 2 + 8,
      y: r * config.tileSize + config.tileSize / 2 + 8,
    };
  }

  function createTiles() {
    const tiles = [];
    for(let r=0; r<config.rows; r++) {
      for(let c=0; c<config.cols; c++) {
        let owner = FACTIONS.neutral;
        if (r === 1 && c === 1) owner = FACTIONS.enemy1;
        else if (r === config.rows - 2 && c === config.cols - 2) owner = FACTIONS.enemy2;
        else if (r === Math.floor(config.rows / 2) && c === Math.floor(config.cols / 2)) owner = FACTIONS.player;

        tiles.push({
          id: tileIndex(c,r),
          owner,
          units: owner === FACTIONS.neutral ? 0 : 5,
          production: 1 + Math.floor(Math.random()*2),
          c, r,
          x: c * config.tileSize + 8,
          y: r * config.tileSize + 8,
          w: config.tileSize - 4,
          h: config.tileSize - 4,
        });
      }
    }
    return tiles;
  }

  function spawnUnits(from, to, owner, count) {
    if(count <= 0) return;
    const fromCenter = centerOfTile(from.c, from.r);
    const toCenter = centerOfTile(to.c, to.r);
    const dx = toCenter.x - fromCenter.x;
    const dy = toCenter.y - fromCenter.y;
    const dist = Math.hypot(dx, dy);
    const vx = (dx/dist) * config.unitSpeed;
    const vy = (dy/dist) * config.unitSpeed;
    state.units.push({
      x: fromCenter.x,
      y: fromCenter.y,
      vx, vy,
      target: to.id,
      owner,
      count,
    });
  }

  function resolveArrival(unit) {
    const tile = state.tiles[unit.target];
    if(!tile) return;
    if(tile.owner === unit.owner || tile.owner === FACTIONS.neutral) {
      if(tile.owner !== unit.owner) {
        // capturing neutral tile
        if(tile.units === 0) {
          tile.owner = unit.owner;
          tile.units = unit.count;
        } else {
          const diff = tile.units - unit.count;
          if(diff > 0) {
            tile.units = diff;
          } else {
            tile.owner = unit.owner;
            tile.units = Math.abs(diff);
          }
        }
      } else {
        tile.units += unit.count;
      }
    } else {
      // fight enemy units
      const diff = tile.units - unit.count;
      if(diff > 0) {
        tile.units = diff;
      } else {
        tile.owner = unit.owner;
        tile.units = Math.abs(diff);
      }
    }
  }

  function launchNuke(centerTile) {
    if(state.resources < config.nukeCost) {
      alert("Not enough resources to launch a nuke!");
      return false;
    }
    state.resources -= config.nukeCost;

    const center = {c: centerTile.c, r: centerTile.r};
    let nuked = 0;

    state.tiles.forEach(tile => {
      const dist = Math.hypot(tile.c - center.c, tile.r - center.r);
      if(dist <= config.nukeRadius) {
        if(tile.owner !== FACTIONS.player) {
          tile.owner = FACTIONS.neutral;
          tile.units = 0;
          nuked++;
        }
      }
    });

    if(nuked > 0) {
      alert(`Nuke launched! Cleared ${nuked} enemy territories.`);
      return true;
    } else {
      alert("Nuke had no effect (no enemy territory in range).");
      return false;
    }
  }

  function aiBehavior(faction) {
    state.tiles.forEach(tile => {
      if(tile.owner !== faction) return;

      // build units randomly
      if(Math.random() < 0.06 * (state.aiFast ? 1.8 : 1)) {
        tile.units++;
      }

      // attack if enough units
      if(tile.units >= 5 && Math.random() < 0.35 * (state.aiFast ? 1.8 : 1)) {
        // find nearest non-faction tile
        const pos = {c: tile.c, r: tile.r};
        let best = null;
        let bestDist = 9999;
        state.tiles.forEach(t => {
          if(t.owner === faction) return;
          const dist = Math.hypot(t.c - pos.c, t.r - pos.r);
          if(dist < bestDist) {
            bestDist = dist;
            best = t;
          }
        });
        if(best) {
          const count = Math.floor(tile.units / 2);
          tile.units -= count;
          spawnUnits(tile, best, faction, count);
        }
      }
    });
  }

  function updateUI() {
    resourcesEl.textContent = state.resources;
    const ownedCount = state.tiles.filter(t => t.owner === FACTIONS.player).length;
    ownedEl.textContent = ownedCount;
    totalEl.textContent = state.tiles.length;
    timeEl.textContent = Math.floor(state.time);
  }

  function drawRoundRect(ctx, x, y, w, h, r, fill, stroke) {
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.lineTo(x+w-r,y);
    ctx.quadraticCurveTo(x+w,y,x+w,y+r);
    ctx.lineTo(x+w,y+h-r);
    ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
    ctx.lineTo(x+r,y+h);
    ctx.quadraticCurveTo(x,y+h,x,y+h-r);
    ctx.lineTo(x,y+r);
    ctx.quadraticCurveTo(x,y,x+r,y);
    ctx.closePath();
    if(fill) ctx.fill();
    if(stroke) ctx.stroke();
  }

  function render() {
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = '#052032';
    ctx.fillRect(0,0,W,H);

    // draw tiles
    state.tiles.forEach(t => {
      ctx.fillStyle = COLORS[t.owner];
      drawRoundRect(ctx, t.x, t.y, t.w, t.h, 8, true, false);

      ctx.strokeStyle = 'rgba(0,0,0,0.4)';
      ctx.lineWidth = 2;
      drawRoundRect(ctx, t.x+1, t.y+1, t.w-2, t.h-2, 8, false, true);

      ctx.fillStyle = '#e6eef6';
      ctx.font = '14px Arial';
      ctx.textAlign = 'left';
      ctx.fillText(`U: ${t.units}`, t.x + 8, t.y + 20);
      ctx.fillText(`P: ${t.production}`, t.x + 8, t.y + 40);

      if(state.selected === t.id) {
        ctx.strokeStyle = 'var(--accent)';
        ctx.lineWidth = 3;
        drawRoundRect(ctx, t.x+3, t.y+3, t.w-6, t.h-6, 8, false, true);
      }
    });

    // draw moving units
    state.units.forEach(u => {
      ctx.fillStyle = COLORS[u.owner];
      ctx.beginPath();
      ctx.arc(u.x, u.y, 8 + u.count * 0.4, 0, 2*Math.PI);
      ctx.fill();
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 1;
      ctx.stroke();
    });
  }

  canvas.addEventListener('mousedown', e => {
    if(state.paused) return;

    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
    const my = (e.clientY - rect.top) * (canvas.height / rect.height);

    for(let t of state.tiles) {
      if(mx >= t.x && mx <= t.x+t.w && my >= t.y && my <= t.y+t.h) {
        if(state.selected === t.id) {
          state.selected = null;
          return;
        }
        if(state.selected !== null) {
          const fromTile = state.tiles[state.selected];
          if(fromTile.owner === FACTIONS.player) {
            let count = e.shiftKey ? Math.floor(fromTile.units/2) : fromTile.units;
            if(count > 0) {
              fromTile.units -= count;
              spawnUnits(fromTile, t, FACTIONS.player, count);
              state.selected = null;
              return;
            }
          }
        }
        if(t.owner === FACTIONS.player) {
          state.selected = t.id;
        } else {
          state.selected = null;
        }
        return;
      }
    }
  });

  window.addEventListener('keydown', e => {
    if(e.code === 'Space') {
      state.paused = !state.paused;
      e.preventDefault();
    }
  });

  buildUnitBtn.onclick = () => {
    if(state.selected === null) return;
    const tile = state.tiles[state.selected];
    if(tile.owner === FACTIONS.player && state.resources >= config.unitCost) {
      state.resources -= config.unitCost;
      tile.units++;
    }
  };

  launchNukeBtn.onclick = () => {
    if(state.selected === null) {
      alert("Select your territory to launch a nuke.");
      return;
    }
    const tile = state.tiles[state.selected];
    if(tile.owner === FACTIONS.player) {
      launchNuke(tile);
    }
  };

  toggleSpeedBtn.onclick = () => {
    state.aiFast = !state.aiFast;
    toggleSpeedBtn.textContent = state.aiFast ? 'Fast AI: ON' : 'Toggle Fast AI';
  };

  restartBtn.onclick = () => {
    init();
  };

  function update(dt) {
    if(state.paused) return;

    state.time += dt;
    state.lastProduction += dt;
    state.lastAITick += dt;

    if(state.lastProduction >= config.productionInterval) {
      let prod = 0;
      state.tiles.forEach(t => {
        if(t.owner === FACTIONS.player) prod += t.production;
      });
      state.resources += prod;
      state.lastProduction = 0;
    }

    // move units
    for(let i = state.units.length - 1; i >= 0; i--) {
      const u = state.units[i];
      u.x += u.vx * dt;
      u.y += u.vy * dt;
      const targetTile = state.tiles[u.target];
      if(!targetTile) {
        state.units.splice(i, 1);
        continue;
      }
      const center = centerOfTile(targetTile.c, targetTile.r);
      if(Math.hypot(u.x - center.x, u.y - center.y) < 8 + u.count*0.3) {
        resolveArrival(u);
        state.units.splice(i, 1);
      }
    }

    if(state.lastAITick >= config.aiTickInterval) {
      aiBehavior(FACTIONS.enemy1);
      aiBehavior(FACTIONS.enemy2);
      state.lastAITick = 0;
    }
  }

  function checkWinLoss() {
    const playerCount = state.tiles.filter(t => t.owner === FACTIONS.player).length;
    const enemyCount = state.tiles.filter(t => t.owner === FACTIONS.enemy1 || t.owner === FACTIONS.enemy2).length;
    if(playerCount === 0) {
      alert("You lost! All your territories were captured.");
      init();
    } else if(enemyCount === 0) {
      alert("Congratulations! You took over the world!");
      init();
    }
  }

  function loop(ts) {
    if(!state.lastTime) state.lastTime = ts;
    const dt = (ts - state.lastTime) / 1000;
    state.lastTime = ts;

    update(dt);
    render();
    updateUI();
    checkWinLoss();

    requestAnimationFrame(loop);
  }

  function init() {
    state.tiles = createTiles();
    state.units = [];
    state.time = 0;
    state.resources = config.startResources;
    state.selected = null;
    state.paused = false;
    state.lastProduction =
